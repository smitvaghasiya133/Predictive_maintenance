# -*- coding: utf-8 -*-
"""Flask_Deployment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DlZc0AI1UDmAlFzNFpPWdRUTEbaip5LG

#Flask

# Config
"""

from google.colab import drive   #connecting to the google drive
drive.mount('/content/drive')

"""Here in this project we will be using ngrock as in colab we can't asses local host"""

!pip install flask-ngrok        #installing Flask ngrock

from flask import Flask, render_template,request,redirect,url_for
from flask_ngrok import run_with_ngrok
from joblib import load
import pandas as pd
import pickle

import warnings

# Suppress all warnings
warnings.filterwarnings("ignore")

"""Installing Complimentary file for ngrok and adding auth"""

! wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-amd64.zip
! unzip ngrok-stable-linux-amd64.zip
! ./ngrok authtoken 2NjAFaec9sHsfPsGJFylrt4AFmy_vDSWbkijbjaB5jfuYtAx

"""#Main Body of the flask"""

app = Flask(__name__,template_folder="/content/drive/MyDrive/GroupProject/Deployment Site") #creating flask app

run_with_ngrok(app)           #runing with ngrok so we will get a single link to see the local host

"""Functions to render html files"""

def render_model_page():
  return render_template("model_page.html")               #rendering the html

def render_output(output_text):
  return render_template('output.html', output_text=output_text)

@app.route("/")
def home():
    return render_template("home.html")             #displaying home html at first
@app.route("/model",methods=['GET', 'POST'])
def model_page():                       
    '''Getting data from user from a from in html by post method'''
    if request.method == 'POST':
        machineID = request.form.get('machineID',0)
        volt = request.form.get('volt',0)
        rotate = request.form.get('rotate',0)
        pressure = request.form.get('pressure',0)
        vibration = request.form.get('vibration',0)
        date_year = request.form.get('date_year',0)
        date_month = request.form.get('date_month',0)
        date_day = request.form.get('date_day',0)
        age = request.form.get('age',0)
        time_hour = request.form.get('time_hour',0)
        model_model1 = request.form.get('model_model1', 0)  # use .get() to handle unchecked checkboxes
        model_model2 = request.form.get('model_model2', 0)
        model_model3 = request.form.get('model_model3', 0)
        model_model4 = request.form.get('model_model4', 0)
        return redirect(url_for('output', machineID=machineID, volt=volt, rotate=rotate, pressure=pressure, vibration=vibration, date_year=date_year, date_month=date_month, date_day=date_day, age=age, time_hour=time_hour, model_model1=model_model1, model_model2=model_model2, model_model3=model_model3, model_model4=model_model4)
)
    return render_template("model_page.html") 

@app.route('/output')
def output():
    '''All the calculations will be done here including input validation and model prediction'''
    machineID = request.args.get('machineID',0)
    volt = request.args.get('volt',0)
    rotate = request.args.get('rotate',0)
    pressure = request.args.get('pressure',0)
    vibration = request.args.get('vibration',0)
    date_year = request.args.get('date_year',0)
    date_month = request.args.get('date_month',0)
    date_day = request.args.get('date_day',0)
    age = request.args.get('age',0)
    time_hour = request.args.get('time_hour',0)
    model_model1 = request.args.get('model_model1', 0)  # use .get() to handle unchecked checkboxes
    model_model2 = request.args.get('model_model2', 0)
    model_model3 = request.args.get('model_model3', 0)
    model_model4 = request.args.get('model_model4', 0)
    # creating a base data frame to store our input data
    dw = pd.DataFrame({
        'machineID': [machineID],
        'volt': [volt],
        'rotate': [rotate],
        'pressure': [pressure],
        'vibration': [vibration],
        'date_year': [date_year],
        'date_month': [date_month],
        'date_day': [date_day],
        'age': [age],
        'time_hour': [time_hour],
        'model_model1': [model_model1],
        'model_model2': [model_model2],
        'model_model3': [model_model3],
        'model_model4': [model_model4],
    })
    
    l1 = ['machineID',
        'volt',
        'rotate',
        'pressure',
        'vibration',
        'date_year',
        'date_month',
        'date_day',
        'age',
        'time_hour',
        'model_model1',
        'model_model2',
        'model_model3',
        'model_model4']
    count2 = 0

    #validating our inputs
    lnif = []
    for i in l1:
      if dw[i].dtypes not in [int,float]:
        lnif.append(i)
        count2 =1
    
    #after validation checking datatypes
    if count2==1:
      try:
        for i in lnif: 
          dw[i].astype(float)
        
        # Validation for empty value   
        val_count =0
        x = dw.columns
        for i in range(len(x)):
          if dw[x[i]].values[0] != 0:
            val_count=1

        # If input values passes all the validation then we will apply scalling and modeling
        if val_count>0:
          with open('/content/drive/MyDrive/GroupProject/Deployment Site/MinMaxScaler.pkl', 'rb') as file:
            mms = pickle.load(file)
          dw = mms.fit_transform(dw)
          rfc = load('/content/drive/MyDrive/GroupProject/Deployment Site/random_forest.joblib')
          prediction = rfc.predict(dw)

        # Making the output readable
          if prediction ==0.0:
            pred = "Your machine will not fail"
          else:
            pred = "Your machine will fail"
          output_text = "Model Say's: " + pred

        else :
          render_model_page()

      #Handeling exception    
      except ValueError as error:
        output_text  = "in exception"
        
    return render_output(output_text)

"""# Run App"""

app.run()